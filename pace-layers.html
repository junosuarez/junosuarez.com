<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pace Layers & Hierarchical Decomposition</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #111827;
        color: #f3f4f6;
        padding: 24px;
        margin: 0;
        min-height: 100vh;
      }
      h1 {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 8px;
      }
      h3 {
        font-size: 0.95rem;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .subtitle {
        color: #9ca3af;
        margin-bottom: 16px;
        max-width: 640px;
      }
      .controls {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }
      button {
        padding: 8px 16px;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }
      button.active-proper {
        background: #2563eb;
        color: white;
      }
      button.active-improper {
        background: #ea580c;
        color: white;
      }
      button.inactive {
        background: #374151;
        color: #d1d5db;
      }
      button:hover {
        opacity: 0.9;
      }
      .main-content {
        display: flex;
        gap: 24px;
        flex-wrap: wrap;
      }
      svg {
        background: #1f2937;
        border-radius: 8px;
      }
      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 16px;
        width: 288px;
      }
      .panel {
        background: #1f2937;
        border-radius: 8px;
        padding: 16px;
      }
      .panel.bordered {
        border: 1px solid #374151;
      }
      .stress-bar-bg {
        height: 16px;
        background: #374151;
        border-radius: 4px;
        overflow: hidden;
      }
      .stress-bar-fill {
        height: 100%;
        transition: width 0.1s, background-color 0.2s;
      }
      .panel-text {
        font-size: 0.9rem;
        color: #6b7280;
        margin-top: 8px;
      }
      .node-info {
        font-size: 0.875rem;
        color: #9ca3af;
      }
      .node-info span {
        color: #60a5fa;
      }
      .node-info .desc {
        font-size: 0.75rem;
        margin-top: 8px;
      }
      .info-section {
        margin-top: 24px;
        background: #1f2937;
        border-radius: 8px;
        padding: 16px;
        max-width: 912px;
      }
      .info-section ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .info-section li {
        font-size: 0.875rem;
        color: #9ca3af;
        margin-bottom: 8px;
      }
      .info-section li .label {
        color: #60a5fa;
      }
      .info-section li .label-green {
        color: #4ade80;
      }
      .info-section li .label-red {
        color: #f87171;
      }
      .info-section li .label-gray {
        color: #d1d5db;
      }
      .ideas-text {
        font-size: 1rem;
        color: #9ca3af;
        margin-bottom: 12px;
        line-height: 1.6;
      }
      .ideas-text em {
        font-style: italic;
      }
      .bibliography {
        margin-bottom: 32px;
      }
      .bibliography li {
        margin-bottom: 12px;
      }
      a {
        color: #60a5fa;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1>Pace Layers & Hierarchical Decomposition</h1>
    <p class="subtitle">
      Each layer oscillates at a different rate. Watch how coupling across
      distant layers creates stress (red lines intensify), while adjacent-layer
      coupling absorbs the pace differential gracefully.
    </p>

    <div class="controls">
      <button
        id="btn-proper"
        class="active-proper"
        onclick="setCouplingMode('proper')"
      >
        Proper Layering
      </button>
      <button
        id="btn-improper"
        class="inactive"
        onclick="setCouplingMode('improper')"
      >
        Improper Coupling
      </button>
      <button id="btn-toggle" class="inactive" onclick="toggleRunning()">
        Pause
      </button>
    </div>

    <div class="main-content">
      <svg id="canvas" width="600" height="380"></svg>

      <div class="sidebar">
        <div class="panel">
          <h3>System Shear Stress</h3>
          <div class="stress-bar-bg">
            <div id="stress-bar" class="stress-bar-fill"></div>
          </div>
          <p id="stress-text" class="panel-text">
            Adjacent-layer interfaces absorb pace differentials
          </p>
        </div>

        <div class="panel">
          <h3 id="selected-title">Click a node</h3>
          <div id="selected-info" class="node-info">
            <p style="color: #6b7280">
              Select a component to see its pace characteristics
            </p>
          </div>
        </div>

        <div class="panel bordered">
          <h3>The Mereological Bet</h3>
          <p id="mereology-text" class="panel-text" style="margin-top: 0">
            Each layer can evolve at its natural pace. Interfaces between
            adjacent layers act as shear-absorbing boundaries. The fast
            presentation layer changes freely; the slow infrastructure layer
            provides stable ground.
          </p>
        </div>
      </div>
    </div>
    <div class="info-section">
      <h3>The Ideas</h3>
      <p class="ideas-text">
        Complex systems that persist—whether evolved or engineered—tend to
        exhibit <em>nearly decomposable</em> hierarchical structure. This means
        interactions within modules are dense, while interactions between
        modules are sparse and channeled through well-defined interfaces.
        Herbert Simon argued this architecture emerges because it's the only way
        to build complex things incrementally: subsystems can stabilize
        independently before being composed. The hierarchy isn't arbitrary; it
        reflects real joints in the causal structure where information and
        energy flow is naturally constrained. In electronics, we see this in how
        ICs encapsulate transistor-level complexity behind pin interfaces. In
        software, we see it in how good APIs screen off implementation details.
        The principle of <em>coarse-graining</em>—safely ignoring lower-level
        details—works precisely because these boundaries exist.
      </p>
      <p class="ideas-text">
        Stewart Brand's <em>pace layers</em> concept adds a temporal dimension
        to this picture. Different layers of a system change at different rates:
        in buildings, the site outlasts the structure which outlasts the wiring
        which outlasts the furniture. In software, language runtimes outlast
        service boundaries which outlast API contracts which outlast UI
        components. Good system design respects these natural paces by placing
        robust interfaces between layers that change at different rates. These
        interfaces absorb "shear stress"—the tension created when a fast-moving
        layer wants to evolve but is coupled to a slow-moving one. When we
        violate pace layer boundary (coupling UI directly to database schemas,
        for instance), we either freeze the fast layer or destabilize the slow
        one. This is technical debt with a temporal multiplier. The mereological
        insight is that decomposition isn't just about spatial modularity—it's
        about temporal coherence. Things that change together should be grouped
        together; things that change at different rates need interfaces that can
        absorb their differential motion.
      </p>
    </div>

    <div class="info-section bibliography">
      <h3>Bibliography</h3>
      <ul>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Herbert_A._Simon"
            target="_blank"
            rel="noopener noreferrer"
            >Herbert A. Simon</a
          >
          — Nobel laureate who developed theories of bounded rationality,
          satisficing, and the architecture of complexity. His 1962 paper "The
          Architecture of Complexity" introduced the concept of nearly
          decomposable systems, explored further in his 1969 opus
          <a href="./sciences-of-the-artificial.html"
            >Sciences of the Artificial</a
          >.
        </li>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Stewart_Brand"
            target="_blank"
            rel="noopener noreferrer"
            >Stewart Brand</a
          >
          — Creator of the Whole Earth Catalog who popularized pace layers in
          his book <em>How Buildings Learn</em> (1994), adapting Frank Duffy's
          "shearing layers" concept.
        </li>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Stuart_Kauffman"
            target="_blank"
            rel="noopener noreferrer"
            >Stuart Kauffman</a
          >
          — Theoretical biologist whose work on self-organization, autonomous
          agents, and the "adjacent possible" explores how complex systems
          maintain themselves and evolve.
        </li>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Murray_Gell-Mann"
            target="_blank"
            rel="noopener noreferrer"
            >Murray Gell-Mann</a
          >
          — Physicist and complexity theorist whose "quark and the jaguar"
          framing highlights the autonomy of explanatory levels and the limits
          of cross-level reduction.
        </li>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Mereology"
            target="_blank"
            rel="noopener noreferrer"
            >Mereology</a
          >
          — The philosophical study of parts and wholes, providing the
          conceptual apparatus for understanding when and how properties of
          wholes can be derived from properties of parts.
        </li>
        <li>
          <a
            href="https://en.wikipedia.org/wiki/Superposition_principle"
            target="_blank"
            rel="noopener noreferrer"
            >Superposition principle</a
          >
          — The property of linear systems that enables decomposition: the
          response to combined inputs equals the sum of responses to each input
          individually.
        </li>
      </ul>
    </div>

    <footer>
      <p style="margin-top: 1em; text-align: center">
        <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a
        ><img
          src="https://mirrors.creativecommons.org/presskit/icons/cc.svg"
          alt=""
          style="max-width: 1em; max-height: 1em; margin-left: 0.2em"
        /><img
          src="https://mirrors.creativecommons.org/presskit/icons/zero.svg"
          alt=""
          style="max-width: 1em; max-height: 1em; margin-left: 0.2em"
        />
        Prepared by
        <a href="https://junosuarez.com" rel="me">Juno Suárez</a> with
        assistance from Claude Opus 4.5. If this is useful, please share or let
        me know.
      </p>
    </footer>

    <script>
      const SVG_NS = "http://www.w3.org/2000/svg";

      const layers = [
        {
          name: "Infrastructure",
          rate: 0.05,
          y: 320,
          color: "#1e3a5f",
          description: "OS, DBMS, language runtime, core protocols",
        },
        {
          name: "Services",
          rate: 0.15,
          y: 240,
          color: "#2d4a6f",
          description: "Bounded contexts owning business logic and data",
        },
        {
          name: "Interface",
          rate: 0.4,
          y: 160,
          color: "#3d5a7f",
          description:
            "API contracts, integration points, component boundaries",
        },
        {
          name: "Presentation",
          rate: 1.0,
          y: 80,
          color: "#4d6a8f",
          description: "UI components, styling, user-facing features",
        },
      ];

      let nodes = [];
      let connections = [];
      let time = 0;
      let running = true;
      let couplingMode = "proper";
      let selectedNode = null;
      let animationId = null;

      // DOM elements
      const canvas = document.getElementById("canvas");
      canvas.addEventListener("click", (e) => {
        if (e.target.tagName === "circle" && e.target.dataset.nodeId) {
          selectNode(e.target.dataset.nodeId);
        }
      });
      const stressBar = document.getElementById("stress-bar");
      const stressText = document.getElementById("stress-text");
      const selectedTitle = document.getElementById("selected-title");
      const selectedInfo = document.getElementById("selected-info");
      const mereologyText = document.getElementById("mereology-text");
      const btnProper = document.getElementById("btn-proper");
      const btnImproper = document.getElementById("btn-improper");
      const btnToggle = document.getElementById("btn-toggle");

      function seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      }

      function generateNodes() {
        nodes = [];
        let seed = 42;
        layers.forEach((layer, layerIdx) => {
          const nodeCount = 4 + layerIdx;
          for (let i = 0; i < nodeCount; i++) {
            const spacing = 500 / (nodeCount + 1);
            nodes.push({
              id: `${layerIdx}-${i}`,
              layerIdx,
              x: 80 + spacing * (i + 1),
              y: layer.y,
              rate: layer.rate * (0.8 + seededRandom(seed++) * 0.4),
              phase: seededRandom(seed++) * Math.PI * 2,
              size: 12 - layerIdx * 1.5,
            });
          }
        });
      }

      function generateConnections() {
        connections = [];
        let seed = 100;

        // Within-layer connections
        layers.forEach((layer, layerIdx) => {
          const layerNodes = nodes.filter((n) => n.layerIdx === layerIdx);
          for (let i = 0; i < layerNodes.length - 1; i++) {
            if (seededRandom(seed++) > 0.3) {
              connections.push({
                from: layerNodes[i].id,
                to: layerNodes[i + 1].id,
                withinLayer: true,
              });
            }
          }
        });

        // Cross-layer connections
        if (couplingMode === "proper") {
          for (let l = 0; l < layers.length - 1; l++) {
            const upperNodes = nodes.filter((n) => n.layerIdx === l);
            const lowerNodes = nodes.filter((n) => n.layerIdx === l + 1);
            upperNodes.forEach((upper, idx) => {
              const lower =
                lowerNodes[
                  Math.floor(seededRandom(seed++) * lowerNodes.length)
                ];
              connections.push({
                from: upper.id,
                to: lower.id,
                withinLayer: false,
                adjacentLayers: true,
              });
            });
          }
        } else {
          // Improper: fast to slow coupling
          const fastNodes = nodes.filter((n) => n.layerIdx === 0);
          const slowNodes = nodes.filter((n) => n.layerIdx === 3);
          fastNodes.forEach((fast, i) => {
            if (i < slowNodes.length) {
              connections.push({
                from: fast.id,
                to: slowNodes[i].id,
                withinLayer: false,
                adjacentLayers: false,
              });
            }
          });
          // Some adjacent connections too
          for (let l = 0; l < layers.length - 1; l++) {
            const upperNodes = nodes.filter((n) => n.layerIdx === l);
            const lowerNodes = nodes.filter((n) => n.layerIdx === l + 1);
            if (upperNodes.length > 0 && lowerNodes.length > 0) {
              connections.push({
                from: upperNodes[0].id,
                to: lowerNodes[0].id,
                withinLayer: false,
                adjacentLayers: true,
              });
            }
          }
        }
      }

      function getNodePhase(node) {
        return node.phase + time * node.rate;
      }

      function getConnectionStress(conn) {
        const fromNode = nodes.find((n) => n.id === conn.from);
        const toNode = nodes.find((n) => n.id === conn.to);
        if (!fromNode || !toNode) return 0;

        if (conn.withinLayer) {
          const phaseDiff = Math.abs(
            Math.sin(getNodePhase(fromNode)) - Math.sin(getNodePhase(toNode))
          );
          return phaseDiff * 0.3;
        } else {
          const phaseDiff = Math.abs(
            Math.sin(getNodePhase(fromNode)) - Math.sin(getNodePhase(toNode))
          );
          return phaseDiff * (conn.adjacentLayers ? 0.5 : 1.0);
        }
      }

      function createSvgElement(tag, attrs) {
        const el = document.createElementNS(SVG_NS, tag);
        for (const [key, value] of Object.entries(attrs)) {
          el.setAttribute(key, value);
        }
        return el;
      }

      function renderStatic() {
        canvas.innerHTML = "";

        // Layer backgrounds and labels
        layers.forEach((layer, idx) => {
          const rect = createSvgElement("rect", {
            x: 60,
            y: layer.y - 30,
            width: 500,
            height: 60,
            fill: layer.color,
            opacity: 0.3,
            rx: 4,
          });
          canvas.appendChild(rect);

          const label = createSvgElement("text", {
            x: 70,
            y: layer.y + 5,
            fill: "#94a3b8",
            "font-size": 11,
            "font-weight": 500,
          });
          label.textContent = layer.name;
          canvas.appendChild(label);

          const tau = createSvgElement("text", {
            x: 570,
            y: layer.y + 5,
            fill: "#64748b",
            "font-size": 10,
            "text-anchor": "end",
          });
          tau.textContent = `τ = ${(1 / layer.rate).toFixed(1)}`;
          canvas.appendChild(tau);
        });

        // Legend
        const legendLine1 = createSvgElement("line", {
          x1: 65,
          y1: 355,
          x2: 85,
          y2: 355,
          stroke: "rgba(100, 200, 150, 0.6)",
          "stroke-width": 1.5,
        });
        canvas.appendChild(legendLine1);
        const legendText1 = createSvgElement("text", {
          x: 90,
          y: 359,
          fill: "#64748b",
          "font-size": 10,
        });
        legendText1.textContent = "Within-layer";
        canvas.appendChild(legendText1);

        const legendLine2 = createSvgElement("line", {
          x1: 185,
          y1: 355,
          x2: 205,
          y2: 355,
          stroke: "rgba(255, 100, 100, 0.6)",
          "stroke-width": 2,
        });
        canvas.appendChild(legendLine2);
        const legendText2 = createSvgElement("text", {
          x: 210,
          y: 359,
          fill: "#64748b",
          "font-size": 10,
        });
        legendText2.textContent = "Cross-layer (stress)";
        canvas.appendChild(legendText2);
      }

      const _node_circles = {};

      function render() {
        // Remove old dynamic elements
        document.querySelectorAll(".dynamic").forEach((el) => el.remove());

        // Connections
        connections.forEach((conn) => {
          const fromNode = nodes.find((n) => n.id === conn.from);
          const toNode = nodes.find((n) => n.id === conn.to);
          if (!fromNode || !toNode) return;

          const stress = getConnectionStress(conn);
          let stroke, strokeWidth;

          if (conn.withinLayer) {
            stroke = `rgba(100, 200, 150, ${0.3 + stress * 0.5})`;
            strokeWidth = 1;
          } else {
            stroke = `rgba(255, 100, 100, ${0.2 + stress * 0.8})`;
            strokeWidth = 1.5 + stress * 2;
          }

          const line = createSvgElement("line", {
            x1: fromNode.x,
            y1: fromNode.y,
            x2: toNode.x,
            y2: toNode.y,
            stroke,
            "stroke-width": strokeWidth,
            class: "dynamic",
            "pointer-events": "none",
          });
          canvas.appendChild(line);
        });

        // Nodes
        nodes.forEach((node) => {
          const phase = getNodePhase(node);
          const intensity = Math.sin(phase) * 0.5 + 0.5;
          const highlighted = selectedNode === node.id;
          const baseColor = highlighted ? [249, 115, 22] : [59, 130, 246];
          const r = Math.round(baseColor[0] * (0.4 + intensity * 0.6));
          const g = Math.round(baseColor[1] * (0.4 + intensity * 0.6));
          const b = Math.round(baseColor[2] * (0.4 + intensity * 0.6));

          let circle = _node_circles[node.id];
          if (!circle) {
            circle = createSvgElement("circle", {
              cx: node.x,
              cy: node.y,
              r: node.size,
              fill: `rgb(${r},${g},${b})`,
              stroke: highlighted ? "#fff" : "#475569",
              "stroke-width": highlighted ? 2 : 1,
              style: "cursor: pointer",
              "data-node-id": node.id,
            });
            canvas.appendChild(circle);
            _node_circles[node.id] = circle;
          } else {
            circle.setAttribute("fill", `rgb(${r},${g},${b})`);
            circle.setAttribute("stroke", highlighted ? "#fff" : "#475569");
            circle.setAttribute("stroke-width", highlighted ? 2 : 1);
          }
        });

        // Update stress meter
        const crossLayerConns = connections.filter((c) => !c.withinLayer);
        const systemStress =
          crossLayerConns.reduce(
            (sum, conn) => sum + getConnectionStress(conn),
            0
          ) / crossLayerConns.length;

        stressBar.style.width = `${Math.min(systemStress * 100, 100)}%`;
        if (systemStress > 0.5) {
          stressBar.style.backgroundColor = "#ef4444";
        } else if (systemStress > 0.3) {
          stressBar.style.backgroundColor = "#f97316";
        } else {
          stressBar.style.backgroundColor = "#22c55e";
        }
      }

      function selectNode(id) {
        selectedNode = selectedNode === id ? null : id;

        if (selectedNode) {
          const node = nodes.find((n) => n.id === selectedNode);
          const layer = layers[node.layerIdx];
          selectedTitle.textContent = `Selected: ${layer.name} component`;
          selectedInfo.innerHTML = `
          <p>Rate: <span>${node.rate.toFixed(2)}</span></p>
          <p>Period: <span>${((Math.PI * 2) / node.rate).toFixed(1)}s</span></p>
          <p class="desc">${layer.description}</p>
        `;
        } else {
          selectedTitle.textContent = "Click a node";
          selectedInfo.innerHTML = `<p style="color: #6b7280;">Select a component to see its pace characteristics</p>`;
        }
      }

      function setCouplingMode(mode) {
        couplingMode = mode;
        generateConnections();

        if (mode === "proper") {
          btnProper.className = "active-proper";
          btnImproper.className = "inactive";
          stressText.textContent =
            "Adjacent-layer interfaces absorb pace differentials";
          mereologyText.textContent =
            "Each layer can evolve at its natural pace. Interfaces between adjacent layers act as shear-absorbing boundaries. The fast presentation layer changes freely; the slow infrastructure layer provides stable ground.";
        } else {
          btnProper.className = "inactive";
          btnImproper.className = "active-improper";
          stressText.textContent =
            "Direct fast↔slow coupling creates chronic stress";
          mereologyText.textContent =
            "When fast components couple directly to slow ones, either the fast layer is constrained (can't evolve) or the slow layer is destabilized (forced to change). This is technical debt with a temporal multiplier.";
        }
      }

      function toggleRunning() {
        running = !running;
        btnToggle.textContent = running ? "Pause" : "Play";
        if (running) {
          animate();
        }
      }

      function animate() {
        if (!running) return;
        time += 0.05;
        render();
        animationId = requestAnimationFrame(animate);
      }

      // Initialize
      generateNodes();
      generateConnections();
      renderStatic();
      animate();
    </script>
  </body>
</html>
